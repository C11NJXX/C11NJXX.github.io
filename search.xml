<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java集合</title>
      <link href="/2023/08/02/LearnJava2/"/>
      <url>/2023/08/02/LearnJava2/</url>
      
        <content type="html"><![CDATA[<p>集合</p><span id="more"></span><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><hr><p>List<br>ArrayList<br>LinkedList<br>List.of()<br>迭代器遍历</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.learn.date.August2023.nd2.demo1._1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="comment">//创建List并使用List.of(),用迭代器遍历</span></span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);<span class="comment">//阅读源码发现，在元素数量为10之前它都有分别的方法，超过10之后方法统一</span></span><br><span class="line">        <span class="keyword">for</span>(Iterator&lt;String&gt; it = list.iterator() ; it.hasNext() ; ) &#123;</span><br><span class="line">            System.out.println(it.next());<span class="comment">//相当于获取完next之后，直接下一个next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二种直接使用for each</span></span><br><span class="line">        <span class="keyword">for</span>(String str : list) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="List和Array的转化"><a href="#List和Array的转化" class="headerlink" title="List和Array的转化"></a>List和Array的转化</h3><h4 id="List-to-Arrat"><a href="#List-to-Arrat" class="headerlink" title="List to Arrat"></a>List to Arrat</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.learn.date.August2023.nd2.demo1._2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//把List转化成Array</span></span><br><span class="line">        List&lt;String&gt; list = List.of(<span class="string">&quot;apple&quot;</span>,<span class="string">&quot;banana&quot;</span>,<span class="string">&quot;grape&quot;</span>);</span><br><span class="line">        method1(list);</span><br><span class="line">        method2(list);</span><br><span class="line">        method3(list);</span><br><span class="line">        <span class="comment">//Object[] array = list.toArray(Integer[]::new);</span></span><br><span class="line">        <span class="comment">//上面的看不懂，函数式写法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="comment">//传入刚好的大小</span></span><br><span class="line">        String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[list.size()]);</span><br><span class="line">        <span class="keyword">for</span> (String str : array) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="comment">//传入相同存储相同类型的Array，如果不够则扩容，如果超过则多余的填为null</span></span><br><span class="line">        list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="comment">//利用toArray返回Object数组</span></span><br><span class="line">        Object[] array = list.toArray();</span><br><span class="line">        <span class="keyword">for</span>(Object o : array) &#123;</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Array-to-List"><a href="#Array-to-List" class="headerlink" title="Array to List"></a>Array to List</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.learn.date.August2023.nd2.demo1._2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayToList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用List.of(),传入对应的Array</span></span><br><span class="line">        Integer[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        List&lt;Integer&gt; list = List.of(nums);</span><br><span class="line">        <span class="comment">//JDK11前</span></span><br><span class="line">        List&lt;Integer&gt; list1 = Arrays.asList(nums);</span><br><span class="line">        <span class="comment">//由于返回的是List，而不是实现类ArrayList或者LinkedList所以无法进行修改</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            list.add(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedOperationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Solution-找出从start到end的缺失的数字并返回"><a href="#Solution-找出从start到end的缺失的数字并返回" class="headerlink" title="Solution(找出从start到end的缺失的数字并返回)"></a>Solution(<em>找出从<strong>start</strong>到<strong>end</strong>的缺失的数字并返回</em>)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.learn.date.August2023.nd2.demo1._3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造从start到end的序列：</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 洗牌算法suffle可以随机交换List中的元素位置:</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        <span class="comment">// 随机删除List中的一个元素:</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">removed</span> <span class="operator">=</span> list.remove((<span class="type">int</span>) (Math.random() * list.size()));</span><br><span class="line">        <span class="type">int</span> <span class="variable">found</span> <span class="operator">=</span> findMissingNumber(start, end, list);</span><br><span class="line">        System.out.println(list.toString());</span><br><span class="line">        System.out.println(<span class="string">&quot;missing number: &quot;</span> + found);</span><br><span class="line">        System.out.println(removed == found ? <span class="string">&quot;测试成功&quot;</span> : <span class="string">&quot;测试失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span> 找出从start到end的缺失的数字并返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMissingNumber</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preSum</span> <span class="operator">=</span> <span class="number">165</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : list) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preSum - sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，集合 </tag>
            
            <tag> List </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型</title>
      <link href="/2023/08/02/LearnJava1/"/>
      <url>/2023/08/02/LearnJava1/</url>
      
        <content type="html"><![CDATA[<p>泛型，擦拭法，extends和super通配符</p><span id="more"></span><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="上界通配符（-lt-extends-Number-gt"><a href="#上界通配符（-lt-extends-Number-gt" class="headerlink" title="上界通配符（ &lt;? extends Number&gt; )"></a>上界通配符（ &lt;? extends Number&gt; )</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PairHelper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(Pair&lt;? extends Number&gt; p)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">        <span class="type">Number</span> <span class="variable">end</span> <span class="operator">=</span> p.getEnd();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + end.intValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">addAfterSet</span><span class="params">(Pair&lt;? extends Number&gt; p)</span> &#123;</span><br><span class="line">        <span class="comment">//由于通配符的存在，p可以指定为任意的Number的子类，但我们的p只能是一个子类T比如Integer，如果说的T是Double或其他子类</span></span><br><span class="line">        <span class="comment">//我在处理T的set的时候，就会把Double或者其他子类set给我的Integer，这样明显是不符合规矩的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为我这里可以接受Number本身及其所有子类，当我去设置的时候，我无法保证我设置的是Integer还是Double</span></span><br><span class="line">        <span class="comment">//因为这两个子类相当于是同级的，他们的父类都是Number，虽然都能接受并且获取（因为使用父类引用所以都能获取）</span></span><br><span class="line">        <span class="comment">//p.setFirst(new Integer(p.getFirst().intValue() + 100));</span></span><br><span class="line">        <span class="comment">//p.setEnd(new Integer(p.getEnd().intValue() + 100));</span></span><br><span class="line">        <span class="type">Number</span> <span class="variable">first</span> <span class="operator">=</span> p.getFirst();</span><br><span class="line">        <span class="type">Number</span> <span class="variable">end</span> <span class="operator">=</span> p.getEnd();</span><br><span class="line">        <span class="keyword">return</span> first.intValue() + end.intValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="super通配符-lt-super-Integer-gt"><a href="#super通配符-lt-super-Integer-gt" class="headerlink" title="super通配符 (&lt; ? super Integer&gt;)"></a>super通配符 (&lt; ? super Integer&gt;)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperPair</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Pair&lt;? <span class="built_in">super</span> Integer&gt; p, Integer first, Integer end)</span> &#123;</span><br><span class="line">        p.setFirst(first);</span><br><span class="line">        p.setEnd(end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(Pair&lt;? <span class="built_in">super</span> Integer&gt; pair)</span> &#123;</span><br><span class="line">        <span class="comment">//由于我的add方法接受了Integer本身及其父类，如果说我传入了Number类，然后在下面获取了first或者end</span></span><br><span class="line">        <span class="comment">//那么就相当于把Number向下转成Integer，这是不合理的</span></span><br><span class="line">        <span class="comment">//Integer first = pair.getFirst();</span></span><br><span class="line">        <span class="comment">//Integer end = pair.getEnd();</span></span><br><span class="line">        <span class="comment">//return first + end;</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassCastException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>extends 和 super的区分方法就是 前者他可以获取当前类（就是extends 后面的类）的本类型及其子类，这样子的话，我在方法里都用父类引用去接收，可以实现泛型的效果，也不会出现类型无法转换，但是这样就带来了无法修改的问题，由于本类和子类的类型都可以被父类引用去接收，所以导致了后续可能会出现不同类进行相互操作，这样是不合理的</p><p>再看super通配符，相当于是设定了一个下界，传入的类都有一个子类是Integer（比如），这样子的话，用可以对可传入的类型（比如Object，Number）进行修改set，即传入Integer（然后就是父类引用接收子类类型），但是却不能get，也就是只能写不能读，因为如果我要读取，然后用子类型去接收，相当于是用子类引用接收父类类型，这是不允许的。</p><p>整体上就是为了实现父类引用接收子类类型</p><p>extends可以get，因为他用父类去接收本类及子类，符合原则，但是他不能set，因为可以接收子类，但是子类之间是平级的，要避免这样的问题</p><p>super可以set，因为我接收子类本类及其父类，然后把子类的值赋给他们，符合原则，但是不能get，因为get的话，相当于用子类引用去get可能出现的父类型。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java，泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode热题:字母异位词分组</title>
      <link href="/2023/07/30/Leetcode2/"/>
      <url>/2023/07/30/Leetcode2/</url>
      
        <content type="html"><![CDATA[<p>记录一下学习算法的过程</p><span id="more"></span><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.leetcode.July.demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="comment">//用于储存质数和以及对应的单词</span></span><br><span class="line">        Map&lt;Double, List&lt;String&gt;&gt; stringMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//用于储存生成的质数的结果(不重复)</span></span><br><span class="line">        Set&lt;Double&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//以下是生成对应质数的字母表</span></span><br><span class="line">        <span class="type">int</span>[] PRIMES = &#123;</span><br><span class="line">                <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>,</span><br><span class="line">                <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span></span><br><span class="line">        &#125;;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span> <span class="variable">currentChar</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> prime : PRIMES) &#123;</span><br><span class="line">            map.put(currentChar, prime);</span><br><span class="line">            currentChar++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始遍历strs</span></span><br><span class="line">        <span class="keyword">for</span> (String word : strs) &#123;</span><br><span class="line">            <span class="type">char</span>[] charArray = word.toCharArray();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isFirst</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">val</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//拆解字符，计算质数积</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> ch : charArray) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isFirst) &#123;</span><br><span class="line">                    val = map.get(ch);</span><br><span class="line">                    isFirst = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    val *= map.get(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//记录质数积</span></span><br><span class="line">            set.add(val);</span><br><span class="line">            <span class="comment">//如果要实现一个key对应多个value，必须要将相同的value存入到集合中，如何判断质数和相同的集合是否存在？</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加到对应的哈希表中,创建相同key值对应的list，再把list拿出来对应添加</span></span><br><span class="line">            <span class="comment">//首先要判断是否存在对应key值的list</span></span><br><span class="line">            <span class="keyword">if</span> (stringMap.containsKey(val)) &#123;</span><br><span class="line">                <span class="comment">//存在，拿出对应的list添加</span></span><br><span class="line">                stringMap.get(val).add(word);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不存在，先添加再拿出list添加</span></span><br><span class="line">                stringMap.put(val, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">                stringMap.get(val).add(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据set集合内的key值，分别输出</span></span><br><span class="line">        <span class="comment">//最终输出</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">double</span> key : set) &#123;</span><br><span class="line">            list.add(stringMap.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (List&lt;List&lt;String&gt;&gt;) list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>先前一直在看算法入门书，感觉到有点乏力之后想来尝试一下leetcode的题目，果然对我是有难度的，这道题目我相当于是借鉴了一个思路，就是将每一个字母对应一个素数，这样子单词拆解之后对应字母的乘积就应该是唯一的，然后我就去写，刚开始对数据结构只是纸面上的了解，顶多就是自己手写过基本功能，这个熟练度导致我在写这种题目的时候对于很多的内置方法是很陌生的，所以我一边写一边问gpt，然后去网上查资料才拼凑出这个能过的解法（之所以说能过是因为空间复杂度被完爆，而且时间复杂度也没好到哪里去，现在至少解出来题目了还有点欣慰）。然后遇到了问题也蛮多，代码里的注释也有，就是一个key对应多个value的情况，在问过gpt后他说可以引入一个第三方库里面有MultiValueMap这个类，我寻思着这没必要于是采取了另一种方法，就是key值代表质数积，然后value是对应的唯一存在的list，然后list再去存储单词，这样的话就需要很多的map，而且我还用了set集合（可以存储不重复的key）值来保存这些质数积，在最后的时候遍历set，然后根据set里面的key值去查找对应的list，再把list遍历。</p><p>整体下来是能符合要求的，对于我这种小白，除了借鉴了质数和避免重复这个思路外，其余的思路都是比较自然的，所以我现在对自己的要求也只是能实现即可（但不能以答案为导向或者是那种…你懂的，就是代码超长…)，路漫漫其修远兮～～～</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 哈希表，字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode热题:两数之和</title>
      <link href="/2023/07/30/Leetcode1/"/>
      <url>/2023/07/30/Leetcode1/</url>
      
        <content type="html"><![CDATA[<p>记录一下学习算法的过程</p><span id="more"></span><h1 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h1><p>两个for循环的解法实在是根深蒂固了，拿到就想用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.leetcode.July.demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">remain</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == remain) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法2（参考）"><a href="#解法2（参考）" class="headerlink" title="解法2（参考）"></a>解法2（参考）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.leetcode.July.demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">remain</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(remain)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(remain), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;没有匹配的数字&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第一次用哈希表解题，这个解法真的优化了时间复杂度,比我之前只用c好多了哈哈哈</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆的数据结构与算法</title>
      <link href="/2023/07/29/LearnAlgorithm2/"/>
      <url>/2023/07/29/LearnAlgorithm2/</url>
      
        <content type="html"><![CDATA[<p>记录一下学习算法和数据结构的过程（堆）</p><p>本博客参考<strong><a href="https://www.hello-algo.com/chapter_tree/">《Hello算法》</a></strong></p><span id="more"></span><h1 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h1><hr><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p><img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/202307291729846.png" alt=""></p><h2 id="学习思路"><a href="#学习思路" class="headerlink" title="学习思路"></a>学习思路</h2><p>学习堆的时候，我自己写了一个类（MyHeap），内部由一个ArrayList维护，主要实现入堆和堆顶元素出堆的操作</p><p>后面还有一个相关的TOP-K问题</p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>堆有很多有意思的地方，就是内部用数组实现的时候，可以考虑进行下标的索引来对外实现为堆（或完全二叉树）</p><p><img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/20230729172830.png" alt=""></p><p><img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/202307291731572.png" alt=""></p><hr><h2 id="难点1-入堆"><a href="#难点1-入堆" class="headerlink" title="难点1:入堆"></a>难点1:入堆</h2><p>为了维护堆的性质，也就是任意的根节点都要大于其子树的元素</p><p>所以入堆的时候就要考虑进行重新整合，也就是堆化操作（heapify）</p><p><strong>MyHeap类（相关代码）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.learn.theme.heapdemo.demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyHeap</span> &#123;</span><br><span class="line">    <span class="comment">//内部维护一个ArrayList，对外表现为堆</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; heap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyHeap</span><span class="params">()</span> &#123;</span><br><span class="line">        heap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据传入的列表进行堆的初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyHeap</span><span class="params">(List&lt;Integer&gt; array)</span> &#123;</span><br><span class="line">        heap = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断堆是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> heap.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取堆大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> heap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取堆顶元素（内部实现即为获取0索引元素）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> heap.get(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Empty!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建映射（获取传入节点的左，右，父节点索引)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeft</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRight</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPre</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//元素入堆操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">//先将元素置于内部队列的尾部（即直接add）</span></span><br><span class="line">        heap.add(val);</span><br><span class="line">        <span class="comment">//加入元素后，可能会不符合堆的性质，要进行堆化(Heapify)</span></span><br><span class="line">        pushHeapify(size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushHeapify</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//从队尾开始，即下标为（size-1）处开始</span></span><br><span class="line">            <span class="comment">//获取父节点下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> getPre(i);</span><br><span class="line">            <span class="comment">//如果父节点下标&lt;0，则代表堆化完成，如果&gt;=0，进行比较</span></span><br><span class="line">            <span class="keyword">if</span> (pre &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;堆化完成&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//获取父节点与当前节点value</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">preVal</span> <span class="operator">=</span> heap.get(pre);</span><br><span class="line">                <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> heap.get(i);</span><br><span class="line">                <span class="comment">//与父节点进行比较，如果比父节点小或等于父节点，堆化完成，否则交换值</span></span><br><span class="line">                <span class="keyword">if</span> (preVal &gt;= val) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;堆化完成&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//交换值(注意这里要用下标设置，否则只交换值没有用，对应位置的值还是没变的）</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> preVal;</span><br><span class="line">                    heap.set(pre, val);</span><br><span class="line">                    heap.set(i, temp);</span><br><span class="line">                    i = pre;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="难点2-堆顶元素出堆"><a href="#难点2-堆顶元素出堆" class="headerlink" title="难点2:堆顶元素出堆"></a>难点2:堆顶元素出堆</h2><h3 id="巧妙处理"><a href="#巧妙处理" class="headerlink" title="巧妙处理"></a>巧妙处理</h3><p>利用先交换堆顶和堆尾元素，巧妙的避免了直接删除堆顶元素再堆化对堆的破坏性</p><p><img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/202307291732179.png" alt=""></p><p><strong>MyHeap类（相关代码）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//堆顶元素出列(采取先交换后堆化的操作)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(<span class="string">&quot;元素为空&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//先交换堆顶元素和堆底元素的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Swap!&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> heap.get(<span class="number">0</span>);</span><br><span class="line">        heap.set(<span class="number">0</span>, heap.get(size() - <span class="number">1</span>));</span><br><span class="line">        heap.set(size() - <span class="number">1</span>, tmp);</span><br><span class="line">        <span class="comment">//删除堆底元素</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Delete!&quot;</span>);</span><br><span class="line">        heap.remove(size() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//堆化操作</span></span><br><span class="line">        popHeapify(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">popHeapify</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//第一次进入下标为0</span></span><br><span class="line">        <span class="comment">//创建临时变量用于保存左右下标</span></span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        l = getLeft(i);</span><br><span class="line">        r = getRight(i);</span><br><span class="line">        <span class="keyword">if</span>(heap.get(l) &gt; heap.get(i) &amp;&amp; heap.get(l) &gt;= heap.get(r)) &#123;</span><br><span class="line">            <span class="comment">//交换左节点和父节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> heap.get(l);</span><br><span class="line">            heap.set(l,heap.get(i));</span><br><span class="line">            heap.set(i,tmp);</span><br><span class="line">            i = l;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(heap.get(r) &gt; heap.get(i) &amp;&amp; heap.get(r) &gt;= heap.get(l)) &#123;</span><br><span class="line">            <span class="comment">//交换右节点和父节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> heap.get(r);</span><br><span class="line">            heap.set(r,heap.get(i));</span><br><span class="line">            heap.set(i,tmp);</span><br><span class="line">            i = r;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;堆化完成&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><strong>MyHeap类（相关代码）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从堆顶开始遍历（测试用）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printHeap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : getHeap()) &#123;</span><br><span class="line">        System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">getHeap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入堆"><a href="#入堆" class="headerlink" title="入堆"></a>入堆</h3><p><strong>Test类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        Integer[] init = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        List&lt;Integer&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(init));</span><br><span class="line">        <span class="type">MyHeap</span> <span class="variable">heap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHeap</span>(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;初始状态&quot;</span>);</span><br><span class="line">        heap.printHeap();</span><br><span class="line">        System.out.println(<span class="string">&quot;入堆&quot;</span>);</span><br><span class="line">        heap.push(<span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;入堆后&quot;</span>);</span><br><span class="line">        heap.printHeap();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h4 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h4><p><img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/202307291742824.png" alt=""></p><h4 id="入堆后"><a href="#入堆后" class="headerlink" title="入堆后"></a>入堆后</h4><p><img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/202307291742824.png" alt=""></p><h4 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始状态</span><br><span class="line">9 8 6 6 7 5 2 1 4 3 6 2 入堆</span><br><span class="line">堆化完成</span><br><span class="line">入堆后</span><br><span class="line">9 8 7 6 7 6 2 1 4 3 6 2 5 </span><br></pre></td></tr></table></figure><hr><h3 id="出堆"><a href="#出堆" class="headerlink" title="出堆"></a>出堆</h3><p><strong>MyHeap类（相关代码）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从堆顶开始遍历（测试用）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printHeap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : getHeap()) &#123;</span><br><span class="line">        System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">getHeap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Test类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.learn.theme.heapdemo.demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化，注意使用Integer包装类，并且使用Arrays的静态方法转换成List传入</span></span><br><span class="line">        Integer[] init2 = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        List&lt;Integer&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(init2));</span><br><span class="line">        <span class="type">MyHeap</span> <span class="variable">heap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHeap</span>(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;初始状态&quot;</span>);</span><br><span class="line">        heap.printHeap();</span><br><span class="line">        System.out.println(<span class="string">&quot;出堆&quot;</span>);</span><br><span class="line">        heap.pop();</span><br><span class="line">        System.out.println(<span class="string">&quot;出堆后&quot;</span>);</span><br><span class="line">        heap.printHeap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h4 id="初始状态-1"><a href="#初始状态-1" class="headerlink" title="初始状态"></a>初始状态</h4><p><img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/202307291745616.png" alt=""></p><h4 id="出堆后"><a href="#出堆后" class="headerlink" title="出堆后"></a>出堆后</h4><p><img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/202307291745616.png" alt=""></p><h4 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果"></a>输出结果</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始状态</span><br><span class="line">9 8 7 6 7 6 2 1 4 3 6 2 5 出堆</span><br><span class="line">Swap!</span><br><span class="line">Delete!</span><br><span class="line">堆化完成</span><br><span class="line">出堆后</span><br><span class="line">8 6 7 5 7 6 2 1 4 3 6 2</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的数据结构与算法</title>
      <link href="/2023/06/30/LearnAlgorithm1/"/>
      <url>/2023/06/30/LearnAlgorithm1/</url>
      
        <content type="html"><![CDATA[<p>记录一下学习算法和数据结构的过程（树）</p><p>本博客参考<strong><a href="https://www.hello-algo.com/chapter_tree/">《Hello算法》</a></strong></p><span id="more"></span><h1 id="二叉树🌳"><a href="#二叉树🌳" class="headerlink" title="二叉树🌳"></a>二叉树🌳</h1><h2 id="1-概念学习"><a href="#1-概念学习" class="headerlink" title="1.概念学习"></a>1.概念学习</h2><p><img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/20230630111354.png" alt=""></p><h3 id="从两种角度去理解二叉树的高度，节点的深度和高度"><a href="#从两种角度去理解二叉树的高度，节点的深度和高度" class="headerlink" title="从两种角度去理解二叉树的高度，节点的深度和高度"></a>从两种角度去理解二叉树的高度，节点的深度和高度</h3><p>从上图来看，这像一颗倒着长的树，那么理解<strong>二叉树的高度</strong>时，就要在脑海里<strong>把这棵树立过来</strong>（从根节点到最远节点）就是树的高度；</p><p>再理解<strong>节点的深度和高度</strong>，就要把这棵树想象成<strong>埋在地里的根</strong>，在比较深度的时候要和地面上的根节点比，在比较高度的时候，要和最深的根去比</p><h2 id="2-二叉树的插入和删除操作"><a href="#2-二叉树的插入和删除操作" class="headerlink" title="2 二叉树的插入和删除操作"></a>2 二叉树的插入和删除操作</h2><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p><strong>TreeNode类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.learn.theme.treedemo.demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.source.tree.Tree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建节点类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> TreeNode left;</span><br><span class="line">    <span class="keyword">private</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = <span class="number">0</span>;</span><br><span class="line">        left = <span class="literal">null</span>;</span><br><span class="line">        right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        left = <span class="literal">null</span>;</span><br><span class="line">        right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(TreeNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(TreeNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showInfo1</span><span class="params">(TreeNode treeNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (treeNode.left != <span class="literal">null</span> &amp;&amp; treeNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(treeNode.value + <span class="string">&quot;节点的左节点为：&quot;</span> + treeNode.left.value + <span class="string">&quot; 该节点的右节点为：&quot;</span> + treeNode.right.value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (treeNode.left != <span class="literal">null</span> &amp;&amp; treeNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(treeNode.value + <span class="string">&quot;节点的左节点为：&quot;</span> + treeNode.left.value + <span class="string">&quot; 该节点的右节点为空 &quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (treeNode.left == <span class="literal">null</span> &amp;&amp; treeNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(treeNode.value + <span class="string">&quot;节点的左节点为空&quot;</span> + <span class="string">&quot; 该节点的右节点为:&quot;</span> + treeNode.right.value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(treeNode.value + <span class="string">&quot;节点为叶节点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showInfo2</span><span class="params">(TreeNode treeNode)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(treeNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//根节点不为空，先打印根节点情况,判断左右节点，按照先左后右顺序打印</span></span><br><span class="line">            TreeNode.showInfo1(treeNode);</span><br><span class="line">           <span class="comment">//利用循环，当碰到叶节点时，停止该分支</span></span><br><span class="line">           <span class="keyword">if</span>(treeNode.left != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">//左节点不为空，作为新的根节点</span></span><br><span class="line">               <span class="type">Thread</span> <span class="variable">leftThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">                       <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                           <span class="meta">@Override</span></span><br><span class="line">                           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                               TreeNode.showInfo2(treeNode.left);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">               );</span><br><span class="line">               leftThread.start();</span><br><span class="line">           &#125;</span><br><span class="line">            <span class="keyword">if</span>(treeNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//左节点不为空，作为新的根节点</span></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">rightThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                                TreeNode.showInfo2(treeNode.right);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                );</span><br><span class="line">                rightThread.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isLeaf</span><span class="params">(TreeNode treeNode)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(treeNode.left == <span class="literal">null</span> &amp;&amp; treeNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">treeNode</span> <span class="operator">=</span> (TreeNode) o;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.value &gt; treeNode.value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.value &lt; treeNode.value) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我用了两个showInfo，第一个比较单纯，没有考虑到如何正确遍历树，后面一个我用了多线程和一个循环结构，配合第一个方法可以打印出正确的树的结构，不过后期应该有更好的遍历方法，这里只是我自己的写法</p><p><strong>Test</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.learn.theme.treedemo.demo1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建二叉树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">treeNode1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">treeNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">treeNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">treeNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">treeNode5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//建立联系</span></span><br><span class="line">        treeNode1.setLeft(treeNode2);</span><br><span class="line">        treeNode1.setRight(treeNode3);</span><br><span class="line">        treeNode2.setLeft(treeNode4);</span><br><span class="line">        treeNode3.setRight(treeNode5);</span><br><span class="line">        <span class="comment">//创建集合存储节点</span></span><br><span class="line">        ArrayList&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(treeNode1);</span><br><span class="line">        list.add(treeNode2);</span><br><span class="line">        list.add(treeNode3);</span><br><span class="line">        list.add(treeNode4);</span><br><span class="line">        list.add(treeNode5);</span><br><span class="line"><span class="comment">//        for (TreeNode treeNode : list) &#123;</span></span><br><span class="line"><span class="comment">//            TreeNode.showInfo1(treeNode);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//TreeNode.showInfo2(treeNode1);</span></span><br><span class="line"></span><br><span class="line">        exert(treeNode1, treeNode2, list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">exert</span><span class="params">(TreeNode treeNode1, TreeNode treeNode2, ArrayList&lt;TreeNode&gt; list)</span> &#123;</span><br><span class="line">        <span class="comment">//测试插入节点</span></span><br><span class="line">        <span class="comment">//二节点的左节点插入6节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">treeNode6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">6</span>);</span><br><span class="line">        list.add(treeNode6);</span><br><span class="line">        treeNode1.setLeft(treeNode6);</span><br><span class="line">        treeNode6.setLeft(treeNode2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;插入6节点后&quot;</span> + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">        TreeNode.showInfo2(treeNode1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="打印结果"><a href="#打印结果" class="headerlink" title="打印结果"></a>打印结果</h3><hr><p>1节点的左节点为：2 该节点的右节点为：3<br>2节点的左节点为：4 该节点的右节点为空<br>3节点的左节点为空 该节点的右节点为:5<br>4节点为叶节点<br>5节点为叶节点</p><hr><h4 id="插入6节点后"><a href="#插入6节点后" class="headerlink" title="插入6节点后"></a>插入6节点后</h4><p>1节点的左节点为：6 该节点的右节点为：3<br>3节点的左节点为空 该节点的右节点为:5<br>6节点的左节点为：2 该节点的右节点为空<br>2节点的左节点为：4 该节点的右节点为空<br>4节点为叶节点<br>5节点为叶节点</p><p><img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/%EF%BC%88%E6%A0%91%EF%BC%89%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9.jpg" alt=""></p><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>这个比较简单，只需要直接把2节点作为1节点的左节点，6就相当于被删除了～</p><h2 id="二叉树的遍历（广度遍历与深度遍历）"><a href="#二叉树的遍历（广度遍历与深度遍历）" class="headerlink" title="二叉树的遍历（广度遍历与深度遍历）"></a>二叉树的遍历（<strong>广度遍历与深度遍历</strong>）</h2><h3 id="层序遍历法（广度遍历优先）"><a href="#层序遍历法（广度遍历优先）" class="headerlink" title="层序遍历法（广度遍历优先）"></a>层序遍历法（广度遍历优先）</h3><p><img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/20230716161656.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.learn.theme.treedemo.demo2;</span><br><span class="line"><span class="keyword">import</span> main.java.learn.theme.treedemo.demo1.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建二叉树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">treeNode1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">treeNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">treeNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">treeNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">treeNode5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//建立联系</span></span><br><span class="line">        treeNode1.setLeft(treeNode2);</span><br><span class="line">        treeNode1.setRight(treeNode3);</span><br><span class="line">        treeNode2.setLeft(treeNode4);</span><br><span class="line">        treeNode3.setRight(treeNode5);</span><br><span class="line">        <span class="comment">//------//</span></span><br><span class="line">        List&lt;Integer&gt; result = method1(treeNode1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : result) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">method1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//层序遍历法，遍历的同时获取节点值</span></span><br><span class="line">        <span class="comment">//用queue存储每个节点(FIFO)</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="comment">//创建一个List存储每个节点值</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//循环判断是否为空</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//非空，队首出列（第一次就是根节点）</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            list.add(node.getValue());</span><br><span class="line">            <span class="comment">//分别判断左右节点(利用queue FIFO的特性，保证遍历顺序)</span></span><br><span class="line">            <span class="keyword">if</span>(node.getLeft() != <span class="literal">null</span> ) &#123;</span><br><span class="line">                queue.add(node.getLeft());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.getRight() != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(node.getRight());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在每一次遍历的时候都会记录当前传入节点的值，并且如果有左右节点，都会按照顺序入队，循环结束证明所有的节点都已经遍历完毕了</span></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p><strong>打印结果</strong></p><p>1<br>2<br>3<br>4<br>5</p><hr><h3 id="前序，后序，中序遍历法-深度遍历优先"><a href="#前序，后序，中序遍历法-深度遍历优先" class="headerlink" title="前序，后序，中序遍历法(深度遍历优先)"></a>前序，后序，中序遍历法(深度遍历优先)</h3><p><strong>先来看看我和gpt的一些问答</strong></p><p><strong>Q1:</strong>前序，中序，后序遍历是什么，为我详细解答一下</p><p><strong>A1:</strong> 前序遍历、中序遍历和后序遍历是二叉树遍历的三种常见方式，用于按照特定顺序访问二叉树中的节点。</p><ol><li><p>前序遍历（Preorder Traversal）：<br>前序遍历先访问根节点，然后按照先左后右的顺序递归地遍历左子树和右子树。即根节点 -&gt; 左子树 -&gt; 右子树。</p></li><li><p>中序遍历（Inorder Traversal）：<br>中序遍历先递归地遍历左子树，然后访问根节点，最后递归地遍历右子树。即左子树 -&gt; 根节点 -&gt; 右子树。</p></li><li><p>后序遍历（Postorder Traversal）：<br>后序遍历先递归地遍历左子树，然后递归地遍历右子树，最后访问根节点。即左子树 -&gt; 右子树 -&gt; 根节点。</p></li></ol><p>这三种遍历方式都是通过递归或栈的辅助实现的。它们可以用来处理二叉树的节点，进行节点值的访问、打印、复制等操作。</p><p>需要注意的是，每种遍历方式在访问节点的顺序和操作时机上有所区别，因此选择适当的遍历方式取决于具体的需求和问题。例如，前序遍历适用于创建二叉树的复制、打印树的结构等；中序遍历适用于搜索树中的节点或按节点值的大小进行排序；后序遍历适用于释放二叉树的内存等操作。</p><p>对于一个给定的二叉树，可以根据需求选择合适的遍历方式来处理树的节点。</p><hr><p><strong>Q2:</strong> 这些顺序的命名由遍历根的顺序决定吗？ </p><p><strong>A2:</strong> 是的，这些遍历方式的命名是根据<strong>根节点的访问顺序</strong>来命名的。</p><ul><li>前序遍历：”前”指的是根节点的访问顺序位于左子树和右子树之前。</li><li>中序遍历：”中”指的是根节点的访问顺序位于左子树和右子树之间。</li><li>后序遍历：”后”指的是根节点的访问顺序位于左子树和右子树之后。</li></ul><p>这样的命名方式有助于描述节点的访问顺序，并且在讨论二叉树遍历时能够更清晰地表达所采用的遍历策略。</p><hr><p><strong>Q3:</strong>不太理解这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 前序遍历 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问优先级：根节点 -&gt; 左子树 -&gt; 右子树</span></span><br><span class="line">    list.add(root.val);</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>A3:</strong>  这段代码实现了二叉树的前序遍历算法。让我逐步解释它的工作原理：</p><ol><li>首先，我们判断根节点是否为空，如果为空，则直接返回。</li><li>如果根节点不为空，我们首先访问当前节点（即将当前节点的值添加到列表中）。</li><li>然后，递归地对左子树进行前序遍历，即调用 <code>preOrder(root.left)</code>。</li><li>接着，递归地对右子树进行前序遍历，即调用 <code>preOrder(root.right)</code>。</li></ol><p>这个过程可以形象地描述为”根节点 -&gt; 左子树 -&gt; 右子树”的访问顺序。每个节点的访问顺序是先访问根节点，然后递归地按照前序遍历顺序访问左子树和右子树。</p><p>通过递归调用，我们可以遍历整棵二叉树，并将节点的值按前序遍历的顺序添加到列表中。</p><hr><p><strong>Q4:</strong>  这里的递归，相当于把左右节点当成一个新的根，左右子树看成新的树，再先遍历根，直到最后传入的左右节点为空为止是吗</p><p><strong>A4:</strong> 正解！在前序遍历算法中，我们首先访问当前节点，然后递归地对左子树和右子树进行前序遍历。每次递归调用时，左子节点和右子节点都被视为新的根节点，然后继续按照前序遍历的方式遍历它们的左右子树。这个过程会一直进行下去，直到遇到空节点为止，然后回溯到上一层继续遍历其他子树。</p><p>可以将递归过程看作是对每个子树的遍历，每个子树的根节点会作为新的起点进行遍历。递归调用的结束条件是遇到空节点，表示已经遍历完该子树。</p><p>通过不断地将左右子节点作为新的根节点进行遍历，我们可以遍历整棵二叉树的所有节点，并按照前序遍历的顺序访问它们。</p><hr><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.learn.theme.treedemo.demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> main.java.learn.theme.treedemo.demo1.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;Integer&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建二叉树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">treeNode1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">treeNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">treeNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">treeNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">treeNode5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">treeNode6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">6</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">treeNode7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">7</span>);</span><br><span class="line">        treeNode1.setLeft(treeNode2);</span><br><span class="line">        treeNode1.setRight(treeNode3);</span><br><span class="line">        treeNode2.setLeft(treeNode4);</span><br><span class="line">        treeNode2.setRight(treeNode5);</span><br><span class="line">        treeNode3.setLeft(treeNode6);</span><br><span class="line">        treeNode3.setRight(treeNode7);</span><br><span class="line">        <span class="comment">//前序遍历法</span></span><br><span class="line">        method1(treeNode1);</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历法&quot;</span>);</span><br><span class="line">        printList(list1);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="comment">//中序遍历法</span></span><br><span class="line">        method2(treeNode1);</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历法&quot;</span>);</span><br><span class="line">        printList(list2);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="comment">//中序遍历法</span></span><br><span class="line">        method3(treeNode1);</span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历法&quot;</span>);</span><br><span class="line">        printList(list3);</span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : list) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;End&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list1.add(root.getValue());</span><br><span class="line">            method1(root.getLeft());</span><br><span class="line">            method1(root.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            method2(root.getLeft());</span><br><span class="line">            list2.add(root.getValue());</span><br><span class="line">            method2(root.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            method3(root.getLeft());</span><br><span class="line">            method3(root.getRight());</span><br><span class="line">            list3.add(root.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果打印：</p><p>前序遍历法<br>1-&gt;2-&gt;4-&gt;5-&gt;3-&gt;6-&gt;7-&gt;End</p><p>中序遍历法<br>4-&gt;2-&gt;5-&gt;1-&gt;6-&gt;3-&gt;7-&gt;End</p><p>后序遍历法<br>4-&gt;5-&gt;2-&gt;6-&gt;7-&gt;3-&gt;1-&gt;End</p><hr><h2 id="二叉搜索树（BinarySearchTree"><a href="#二叉搜索树（BinarySearchTree" class="headerlink" title="二叉搜索树（BinarySearchTree)"></a>二叉搜索树（BinarySearchTree)</h2><p><img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/20230718142502.png" alt=""></p><h3 id="二叉搜索树的构造"><a href="#二叉搜索树的构造" class="headerlink" title="二叉搜索树的构造"></a>二叉搜索树的构造</h3><p><strong>BinarySearchTree类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.learn.theme.treedemo.demo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> main.java.learn.theme.treedemo.demo1.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearchTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode root;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinarySearchTree</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">getRoot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">insertNode</span><span class="params">(TreeNode root, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//如果二叉树没有生成，传入的第一个值作为根值</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.getValue() &lt; value) &#123;</span><br><span class="line">            <span class="comment">//如果传入的值大于根值，需要进入右节点,递归插入</span></span><br><span class="line">            root.setRight(insertNode(root.getRight(),value));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.getValue() &gt; value) &#123;</span><br><span class="line">            <span class="comment">//同理，递归插入左节点</span></span><br><span class="line">            root.setLeft(insertNode(root.getLeft(),value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> val : nums) &#123;</span><br><span class="line">            root = insertNode(root,val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历法</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            inorderTraversal(root.getLeft());</span><br><span class="line">            list.add(root.getValue());</span><br><span class="line">            inorderTraversal(root.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过递归插入节点，例如当第一次插入节点时，该节点作为根节点，当插入下一个节点时，根据节点大小的比较，对应插入到当前根节点的左/右节点，并且利用递归的思想，将插入的新的节点作为新的根节点，再去进一步判断，这样，只需要知道一个根节点，就能获取到一颗二叉搜索树，并且通过中序遍历法验证，得到一个升序的序列</p><p><strong>通过逐步调试可以发现，这个构造原理就是通过不断的将新插入的值与当前节点值比较，一直向下寻找合适的位置，如果当前“根”节点不为空，那么就要继续向下，判断要插在左还是右，如果此时节点为null，那么就有了属于当前值的位置，插入即可</strong></p><hr><p><strong>Test类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.learn.theme.treedemo.demo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> main.java.learn.theme.treedemo.demo1.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">8</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] values = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">14</span>&#125;;</span><br><span class="line">        <span class="type">BinarySearchTree</span> <span class="variable">binarySearchTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySearchTree</span>();</span><br><span class="line">        binarySearchTree.buildTree(arr);</span><br><span class="line">        List&lt;Integer&gt; list = binarySearchTree.inorderTraversal(binarySearchTree.getRoot());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : list) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出结果:</strong></p><p>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 </p><hr><h3 id="二叉搜索树的查找"><a href="#二叉搜索树的查找" class="headerlink" title="二叉搜索树的查找"></a>二叉搜索树的查找</h3><p><img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/20230722111952.png" alt=""></p><p><strong>代码实现</strong></p><p><strong>Test02</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.learn.theme.treedemo.demo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> main.java.learn.theme.treedemo.demo1.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">8</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        <span class="type">BinarySearchTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySearchTree</span>();</span><br><span class="line">        tree.buildTree(arr);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> tree.getRoot();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">resTreeNode</span> <span class="operator">=</span> search(root, <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">search</span><span class="params">(TreeNode root, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (root.getValue() == num) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;find num &quot;</span> + root.getValue() + <span class="string">&quot; in level &quot;</span> + count);</span><br><span class="line">                    <span class="keyword">return</span> root;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.getValue() &lt; num) &#123;</span><br><span class="line">                    root = root.getRight();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    root = root.getLeft();</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Root is null&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>输出结果</p><p>find num 7 in level 4</p><hr><h3 id="二叉搜索树的删除操作"><a href="#二叉搜索树的删除操作" class="headerlink" title="二叉搜索树的删除操作"></a>二叉搜索树的删除操作</h3><p>删除比较复杂，需要分析所删除的节点的度数，进行分类讨论</p><hr><h4 id="度数为0（叶节点"><a href="#度数为0（叶节点" class="headerlink" title="度数为0（叶节点)"></a>度数为0（叶节点)</h4><p>当度数为0时，只需要通过查找的方法，找到节点，判断是否为叶子，然后根据其位于pre节点的左或右进行删除即可</p><p><img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/202307231038366.png" alt=""></p><hr><h4 id="度数为1"><a href="#度数为1" class="headerlink" title="度数为1"></a>度数为1</h4><p>当度数为1时，需要根据左右位置，进行覆盖操作来达到删除效果</p><p><img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/202307231136430.png" alt=""></p><hr><h4 id="度数为2时"><a href="#度数为2时" class="headerlink" title="度数为2时"></a>度数为2时</h4><p>度数为2比较复杂，需要保证二叉搜索树，左根右的一个升序，所以在找到删除节点之后要去找到该节点的左子树的右节点，或者该节点右子树的左节点,并且先记录后递归删除，再进行值替换</p><p><img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/202307231154332.png" alt=""></p><hr><p><strong>整体代码</strong></p><p><strong>Test04</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main.java.learn.theme.treedemo.demo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> main.java.learn.theme.treedemo.demo1.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  删除节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test04</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> BinarySearchTree.getBuiltTree();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//printTree(root);</span></span><br><span class="line"></span><br><span class="line">        method1(root);</span><br><span class="line">        method2(root);</span><br><span class="line">        method3(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//测试是否能正常删除度数为2的节点</span></span><br><span class="line">        deleteNode(root, <span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;delete 4&quot;</span>);</span><br><span class="line">        printTree(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//测试是否能正常删除度数为1的节点</span></span><br><span class="line">        deleteNode(root, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;delete 2&quot;</span>);</span><br><span class="line">        printTree(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//测试是否能正常删除叶节点</span></span><br><span class="line">        deleteNode(root, <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;delete 1&quot;</span>);</span><br><span class="line">        printTree(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">preNode</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (root.getValue() == val) &#123;</span><br><span class="line">                    <span class="comment">//当前节点为所删除节点</span></span><br><span class="line">                    <span class="keyword">if</span> (isLeaf(root)) &#123;</span><br><span class="line">                        <span class="comment">//如果是叶节点</span></span><br><span class="line">                        <span class="comment">//根据左右节点,直接删除</span></span><br><span class="line">                        <span class="keyword">if</span> (preNode.getValue() &gt; val) &#123;</span><br><span class="line">                            preNode.setLeft(<span class="literal">null</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (preNode.getValue() &lt; val) &#123;</span><br><span class="line">                            preNode.setRight(<span class="literal">null</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isOneLeaf(root)) &#123;</span><br><span class="line">                        <span class="comment">//节点度数为1</span></span><br><span class="line">                        <span class="comment">//根据左右节点，覆盖</span></span><br><span class="line">                        <span class="keyword">if</span> (preNode.getValue() &gt; val) &#123;</span><br><span class="line">                            <span class="comment">//root在pre的左节点位置</span></span><br><span class="line">                            <span class="comment">//判断左右哪个为null</span></span><br><span class="line">                            <span class="keyword">if</span> (root.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//使用右节点</span></span><br><span class="line">                                preNode.setLeft(root.getRight());</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//使用左节点</span></span><br><span class="line">                                preNode.setLeft(root.getLeft());</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (preNode.getValue() &lt; val) &#123;</span><br><span class="line">                            <span class="comment">//root在pre的右节点</span></span><br><span class="line">                            <span class="keyword">if</span> (root.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//使用右节点</span></span><br><span class="line">                                preNode.setRight(root.getRight());</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//使用左节点</span></span><br><span class="line">                                preNode.setRight(root.getLeft());</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isTwoLeaf(root)) &#123;</span><br><span class="line">                        <span class="comment">//2度节点，采取右子树左节点替换法</span></span><br><span class="line">                        <span class="comment">//获取右子树左节点</span></span><br><span class="line">                        <span class="type">TreeNode</span> <span class="variable">nex</span> <span class="operator">=</span> root.getRight().getLeft();</span><br><span class="line">                        <span class="comment">//递归删除右子树左节点（不知道是叶还是1度还是2度）</span></span><br><span class="line">                        deleteNode(root, nex.getValue());</span><br><span class="line">                        <span class="comment">//将nex节点替换到root节点</span></span><br><span class="line">                        root.setValue(nex.getValue());</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.getValue() &lt; val) &#123;</span><br><span class="line">                    <span class="comment">//所要查找的节点在右边</span></span><br><span class="line">                    preNode = root;</span><br><span class="line">                    root = root.getRight();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//所要查找的节点在左边</span></span><br><span class="line">                    preNode = root;</span><br><span class="line">                    root = root.getLeft();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isLeaf</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.getLeft() == <span class="literal">null</span> &amp;&amp; root.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isOneLeaf</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isLeaf(root) &amp;&amp; !isTwoLeaf(root)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isTwoLeaf</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.getLeft() != <span class="literal">null</span> &amp;&amp; root.getRight() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">            emptyPrintTree(root);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list.clear();</span><br><span class="line">            emptyPrintTree(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">emptyPrintTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        list = inorderTraversal(root);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : list) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            inorderTraversal(root.getLeft());</span><br><span class="line">            list.add(root.getValue());</span><br><span class="line">            inorderTraversal(root.getRight());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果</p><p>delete 1<br>2 3 4 5 6 7 8 9 10 11 12 13 14 15<br>delete 2<br>3 4 5 6 7 8 9 10 11 12 13 14 15<br>delete 4<br>3 5 6 7 8 9 10 11 12 13 14 15 </p><p>这里写的时候，中间遇到了一些与树无关的一些问题，比如循环，return，还有采取static list必须要每次判断是否为empty，不然打印效果不好</p><hr>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂谈</title>
      <link href="/2023/06/21/life1/"/>
      <url>/2023/06/21/life1/</url>
      
        <content type="html"><![CDATA[<p>记录一下最近生活吧</p><span id="more"></span><h1 id="近日总结"><a href="#近日总结" class="headerlink" title="近日总结"></a>近日总结</h1><h2 id="1-学习上"><a href="#1-学习上" class="headerlink" title="1.学习上"></a>1.学习上</h2><p>鸽了三四天没有再搞博客上的文章和装饰，直到今天下午才闲的一些功夫来写下博客，这两日是学校的期末周时间，我已经考完了高等数学和线性代数，还有大学物理，大学英语，Java 和离散数学没有考，只能说还是挺忙碌的，大学物理还在雾里（😭），但是我相信老师（👨‍🏫）的重点是真的考点，那我在端午就放心的去做那些题目了（虽然还是很多😮‍💨）</p><p>晒一张图书馆往外看的漫画云～☁️</p><p><img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/IMG_6490.jpg" alt=""></p><h2 id="2-生活上"><a href="#2-生活上" class="headerlink" title="2.生活上"></a>2.生活上</h2><p>这两日下午一般都学的很晚，正是夕阳美景的时光🌇</p><p><img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/IMG_6443.jpg" alt=""></p><p><img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/IMG_6491.jpg" alt=""></p><p>篝火民谣之夜依旧是氛围感十足😄</p><p><img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/IMG_6465.jpg" alt=""></p><h2 id="浅浅的总结一下"><a href="#浅浅的总结一下" class="headerlink" title="浅浅的总结一下"></a>浅浅的总结一下</h2><p>这两日其实想说的没有很多，生活都是去体会的，哈哈，其实是我懒，我会更多的分享学习上的博客，但是生活是我们必不可少的永恒</p><p>bye～👋</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭个站的小心得</title>
      <link href="/2023/06/18/%E6%90%AD%E4%B8%AA%E7%AB%99%E7%9A%84%E5%B0%8F%E5%BF%83%E5%BE%97/"/>
      <url>/2023/06/18/%E6%90%AD%E4%B8%AA%E7%AB%99%E7%9A%84%E5%B0%8F%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<p>记录一下还没有完全建好但是大致能用的网站的建立心得体会</p><span id="more"></span><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol><li><a href="#1-为啥要建站">为啥要建站</a></li><li><a href="#2-建站的过程">建站的过程</a></li><li><a href="#3-遇到哪些问题">遇到哪些问题</a></li><li><a href="#4-写在最后">写在最后</a></li></ol><h2 id="1-为啥要建站？"><a href="#1-为啥要建站？" class="headerlink" title="1.为啥要建站？"></a>1.为啥要建站？</h2><ol><li>平时我自己有写一些记录的习惯，无论是生活还是学习，我觉得记录总是有意义的</li><li>在建站之前我本来是这样想的：自己学习 HTML，CSS，JavaScript，还有一些相关知识，<br>然后搭出一个属于自己的网站，并且把这个作为一个长期的目标，但是偶然间发现了这种现成的<br> 框架，发现是真的不错，就连着花了两天的时间搭出了一个雏形来</li><li>一个学习编程的人怎么能没有博客呢哈哈哈</li></ol><h2 id="2-建站的过程"><a href="#2-建站的过程" class="headerlink" title="2. 建站的过程"></a>2. 建站的过程</h2><ol><li><p>当时是先面向 CSDN 建站，大佬的教程很不错，跟着把一些环境都配置好了，但是没有用大佬的推荐的<br>butterfly 主题，用了volantis，也很不错！在这里鸣谢一下～.</p><p> —&gt;<a href="https://coder-jason.cn/2022/01/19/setup-personal-blog/">建站博客</a>.</p><p> —&gt;<a href="https://volantis.js.org">volantis</a></p></li><li>这两天其实一直沉迷于一些魔改，想把自己的网站做的很花，收藏了很多很多人的博客教程，以及一些 github 项目<br> 这里贴个图，就不一一感谢了，后面还会继续学习大佬们的博客文章！  <img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/20230614230952.png" alt=""><ol><li><strong>这里重点感谢一位大佬的博客，帮助我在原博客本地文件损坏的情况下用 butterfly 主题重建了博客，并且非常好看！！！</strong><br>这里贴大佬的网站 —&gt;<a href="https://www.fomal.cn">fomal</a><br><img src="https://c11njxxsblog.oss-cn-hangzhou.aliyuncs.com/20230616115401.png" alt=""><h2 id="3-遇到哪些问题"><a href="#3-遇到哪些问题" class="headerlink" title="3. 遇到哪些问题"></a>3. 遇到哪些问题</h2></li></ol></li><li>一个就是我没学过 HTML，CSS，js 的一些知识，对于里面的代码逻辑其实是不懂的，一切都是靠实际调试出来的</li><li>还有一个就是对于这个学习别人的建站教程，对应到自己这里还是有些细节上难以处理的问题，还得慢慢学习</li></ol><h2 id="4-写在最后"><a href="#4-写在最后" class="headerlink" title="4. 写在最后"></a>4. 写在最后</h2><p>这篇博文其实也是第一次比较正式的在自己的博客上写文章，也是比较符合我的一个心得记录.</p><p>感觉知识是没有尽头的，最近在学习很多新的知识，在不断的学习中才感到自己的渺小，希望这个博客能见证<br>我的一步步成长，我也会不定期的在这里发布我的学习生活心得，并且不断的完善和美化优化我的博客，<br>就这样吧～～～😄</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
          <category> 心得 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心得体会 </tag>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两道离散数学中的算法题</title>
      <link href="/2023/06/18/%E4%B8%A4%E9%81%93%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/2023/06/18/%E4%B8%A4%E9%81%93%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>记录一下在学习离散数学的时候的两个实验，用 java 实现 warshall 算法来求传递闭包，用Kruskal 算法来求最小生成树</p><span id="more"></span><hr><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p> <strong>1.Warshall 算法求传递闭包</strong><br><a href="#section1">1.实验过程中遇到的问题及其解决过程</a><br><a href="#section2">2.实现算法并编写一个程序求出给定关系的闭包</a><br><a href="#section3">3.实验结束时的程序清单及运行结果及实验总结</a></p><p><strong>2.Kruskal 算法求最小生成树</strong><br><a href="#section4">1.实验过程中遇到的问题及其解决过程</a><br><a href="#section5">2.利用Java语言编写一个程序求出给定无向连通加权图的一棵最小生成树</a><br><a href="#section6">3.实验结束时的程序清单及运行结果及实验总结</a></p><hr><h2 id="1-Warshall-算法求传递闭包"><a href="#1-Warshall-算法求传递闭包" class="headerlink" title="1.Warshall 算法求传递闭包"></a>1.Warshall 算法求传递闭包</h2><p><a name="section1"></a></p><h3 id="1-实验过程遇到的问题及其解决过程"><a href="#1-实验过程遇到的问题及其解决过程" class="headerlink" title="1.实验过程遇到的问题及其解决过程"></a>1.实验过程遇到的问题及其解决过程</h3><p>如何设计算法，利用自然的逻辑进行，先循环每一行i，在检查第 i 列有哪些元素为 1，记录这些列号 j，把第 i 行的元素利用逻辑加法（我采用了三目运算）加到第 j 行，这里引入了第三层循环 ，并且每次运算都做了打印处理方便调试<br><a name="section2"></a></p><h3 id="2-实现算法并编写一个程序求出给定关系的闭包"><a href="#2-实现算法并编写一个程序求出给定关系的闭包" class="headerlink" title="2.实现算法并编写一个程序求出给定关系的闭包"></a>2.实现算法并编写一个程序求出给定关系的闭包</h3><p><strong>Warshall类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Warshall</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化矩阵</span></span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                arr[i][j] = <span class="number">0</span>;<span class="comment">//先将所有元素设置为 0，再具体添加测试</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        printArr(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//warshall算法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//循环每一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//看第 i 列哪些元素为 1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//第 j 行 i 列的元素为 1</span></span><br><span class="line">                    <span class="comment">//把第 i 行的所有元素逻辑加到第 j 行</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>; s &lt; <span class="number">4</span>; s++) &#123;</span><br><span class="line">                        arr[j][s] = (arr[j][s] + arr[i][s]) == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;<span class="comment">//利用三目运算符</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//每循环一行打印一次矩阵</span></span><br><span class="line">            System.out.println(<span class="string">&quot;\n----------第&quot;</span> + count + <span class="string">&quot;次-----------\n&quot;</span>);</span><br><span class="line">            printArr(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArr</span><span class="params">(<span class="type">int</span>[][] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] i : arr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">4</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(j + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="section3"></a></p><h3 id="3-实验结束的程序清单及运行结果及实验总结"><a href="#3-实验结束的程序清单及运行结果及实验总结" class="headerlink" title="3.实验结束的程序清单及运行结果及实验总结"></a>3.实验结束的程序清单及运行结果及实验总结</h3><p>0 1 0 0</p><p>0 0 1 1</p><p>1 1 0 0</p><p>1 0 0 0<br>—————第1次—————-</p><p>0 1 0 0</p><p>0 0 1 1</p><p>1 1 0 0</p><p>1 1 0 0<br>—————第2次—————-</p><p>0 1 1 1</p><p>0 0 1 1</p><p>1 1 1 1</p><p>1 1 1 1<br>—————第3次—————-</p><p>1 1 1 1</p><p>1 1 1 1</p><p>1 1 1 1</p><p>1 1 1 1<br>—————第4次—————-</p><p>1 1 1 1</p><p>1 1 1 1</p><p>1 1 1 1</p><p>1 1 1 1<br>Process finished with exit code 0<br>实验总结：<br>编写程序之前要理解 warshall 算法的步骤，才能清晰的写出程序运行逻辑</p><hr><h2 id="2-Kruskal-算法求最小生成树"><a href="#2-Kruskal-算法求最小生成树" class="headerlink" title="2.Kruskal 算法求最小生成树"></a>2.Kruskal 算法求最小生成树</h2><p><a name="section4"></a></p><h3 id="1-实验过程中遇到的问题及其解决过程"><a href="#1-实验过程中遇到的问题及其解决过程" class="headerlink" title="1.实验过程中遇到的问题及其解决过程"></a>1.实验过程中遇到的问题及其解决过程</h3><p>难点在于怎么样把图 G<V,E,C>设计成一些类的组合   </p><p>我在实现过程中，封装了 Graph 类表示图，Edge 表示边，并且把权重封装在 Edge 类中作为属性(为了方便权限设置为 public)，并且在 Graph 类中创建静态方法，实现打印点，边，按权重为边集合排序和初始化边集合的静态方法，直接在 main 方法中用 Edge 类调用，在 Kruskal 类中，我抽取了三个静态方法，实现 main 方法的简洁性，提高了代码的阅读性。   </p><p>第一个静态方法是设置点集合，可以在静态方法中自己调试点的个数，同理第二个静态方法是设置边集合，可以调试一些带权连通图，只需要把这些关系自己创建出对应的边即可，第三个静态方法是 Kruskal 算法的实现，我在里面利用一些计数器原理判断是否已经添加了（点数 -1）条边，并且利用 Graph 类封装的 isAdd 属性配合一个判断是否有回路的算法，来生成最小生成树的图newGraph</p><p> 中间遇到了一些问题通过断点调试 debug 解决了，主要是一些下标处理问题，在没有 isAdd 属性的时候，会有一些造成回路的边被重复判断，还有是引入了 count 防止跳过造成回路的边之后，i 的值作为下标赋值给新边的时候造成 ArrayIndexOutOfBounds 异常，暂且测试了两个例子，后面有时间会进行更多测试，并且支持自定义添加图，并判断是否为连通图再进行最小生成树的生成操作</p><p><a name="section5"></a></p><h3 id="2-利用Java语言编写一个程序求出给定无向连通加权图的一棵最小生成树"><a href="#2-利用Java语言编写一个程序求出给定无向连通加权图的一棵最小生成树" class="headerlink" title="2.利用Java语言编写一个程序求出给定无向连通加权图的一棵最小生成树"></a>2.利用Java语言编写一个程序求出给定无向连通加权图的一棵最小生成树</h3><p><strong>Kruskal类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kruskal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//设置点集合</span></span><br><span class="line">        <span class="type">int</span>[] points = setPoint();</span><br><span class="line">        <span class="comment">//设置边集合</span></span><br><span class="line">        Edge[] edges = setEdge();</span><br><span class="line">        <span class="comment">//Kruskal算法</span></span><br><span class="line">        kruskalMethod(points, edges);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">kruskalMethod</span><span class="params">(<span class="type">int</span>[] points, Edge[] edges)</span> &#123;</span><br><span class="line">        <span class="comment">//Kruskal算法</span></span><br><span class="line">        <span class="comment">//按照权重从小到大的顺序添加边，已经排序好了直接按照边序号来</span></span><br><span class="line">        <span class="comment">//创建新图(只需要点的总数-1 条边）</span></span><br><span class="line">        Edge[] newEdge = <span class="keyword">new</span> <span class="title class_">Edge</span>[points.length - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化新边集合</span></span><br><span class="line">        Graph.setEmptyEdge(newEdge);</span><br><span class="line">        <span class="type">Graph</span> <span class="variable">newGraph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(points, newEdge);</span><br><span class="line">        <span class="comment">//循环添加新边</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">            <span class="comment">//设置第一,二条边</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == <span class="number">1</span>) &#123;</span><br><span class="line">                newGraph.edges[i].point1 = edges[i].point1;</span><br><span class="line">                newGraph.edges[i].point2 = edges[i].point2;</span><br><span class="line">                newGraph.edges[i].weight = edges[i].weight;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当边数超过三时，需要判断是否形成回路，如果新生成的边的终点和前面已存在的边的起点重合，则判断为回路</span></span><br><span class="line">                <span class="keyword">if</span> (count == points.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;已添加完&quot;</span> + count + <span class="string">&quot;条边，不再继续添加(注意：本算法只列出了一种最小生成树！）&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//利用循环判断是否有回路</span></span><br><span class="line">                <span class="type">int</span> j;</span><br><span class="line">                <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                    <span class="comment">//如果跳过了一条边，也相当于添加过了，就不要再重新比了，相当于做了一个标记，这条边我不要</span></span><br><span class="line">                    <span class="keyword">if</span> (edges[i].point2 == edges[j].point1 &amp;&amp; !edges[j].isAdd) &#123;</span><br><span class="line">                        edges[i].isAdd = <span class="literal">true</span>;</span><br><span class="line">                        System.out.println(<span class="string">&quot;有回路，跳过原第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot; 条边&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断上方是否正常跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//break 跳出，说明有回路，更新 i 为下一条边</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//正常退出，正常添加新边,注意要用 count 来为新的边赋值，否则会随着一些边的跳过，导致 i 作为新边下标的越界问题</span></span><br><span class="line">                    newGraph.edges[count].point1 = edges[i].point1;</span><br><span class="line">                    newGraph.edges[count].point2 = edges[i].point2;</span><br><span class="line">                    newGraph.edges[count].weight = edges[i].weight;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看新边集合</span></span><br><span class="line">        Graph.printEdges(newGraph.edges);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] setPoint() &#123;</span><br><span class="line">        <span class="comment">//创建点集合</span></span><br><span class="line">        <span class="type">int</span>[] points = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//将点集合的值视为编号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            points[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印点集合</span></span><br><span class="line">        Graph.printPoints(points);</span><br><span class="line">        <span class="keyword">return</span> points;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Edge[] setEdge() &#123;</span><br><span class="line">        <span class="comment">//构造连通图</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1-2,5</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2-3,5</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3-5,6</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2-4,12</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 4-5,12</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2-5,15</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3-4,17</span></span><br><span class="line"><span class="comment">         //         */</span></span><br><span class="line"><span class="comment">//        Edge[] edges = new Edge[7];</span></span><br><span class="line"><span class="comment">//        edges[0] = new Edge(1, 2, 5);</span></span><br><span class="line"><span class="comment">//        edges[1] = new Edge(2, 3, 5);</span></span><br><span class="line"><span class="comment">//        edges[2] = new Edge(3, 5, 6);</span></span><br><span class="line"><span class="comment">//        edges[3] = new Edge(2, 4, 12);</span></span><br><span class="line"><span class="comment">//        edges[4] = new Edge(4, 5, 12);</span></span><br><span class="line"><span class="comment">//        edges[5] = new Edge(2, 5, 15);</span></span><br><span class="line"><span class="comment">//        edges[6] = new Edge(3, 4, 17);</span></span><br><span class="line">        Edge[] edges = <span class="keyword">new</span> <span class="title class_">Edge</span>[<span class="number">8</span>];</span><br><span class="line">        edges[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        edges[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">        edges[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">        edges[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">        edges[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        edges[<span class="number">5</span>] = <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">        edges[<span class="number">6</span>] = <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        edges[<span class="number">7</span>] = <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//按权重排序</span></span><br><span class="line">        Graph.sortEdge(edges);</span><br><span class="line">        <span class="comment">//打印边集合</span></span><br><span class="line">        Graph.printEdges(edges);</span><br><span class="line">        <span class="keyword">return</span> edges;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Graph类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] points;</span><br><span class="line">    <span class="keyword">public</span> Edge[] edges;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span>[] points, Edge[] edges)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.points = points;</span><br><span class="line">        <span class="built_in">this</span>.edges = edges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printPoints</span><span class="params">(<span class="type">int</span>[] points)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : points) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;点 &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printEdges</span><span class="params">(Edge[] edges)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge e : edges) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;第&quot;</span> + count + <span class="string">&quot;条边 : &quot;</span>);</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sortEdge</span><span class="params">(Edge[] edges)</span> &#123;</span><br><span class="line">        <span class="comment">//遍历权重</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; edges.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (edges[j].weight &lt; edges[i].weight) &#123;</span><br><span class="line">                    <span class="type">Edge</span> <span class="variable">tmp</span> <span class="operator">=</span> edges[j];</span><br><span class="line">                    edges[j] = edges[i];</span><br><span class="line">                    edges[i] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setEmptyEdge</span><span class="params">(Edge[] edges)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">            edges[i] = <span class="keyword">new</span> <span class="title class_">Edge</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Edge类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> point1;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> point2;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> isAdd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> point1, <span class="type">int</span> point2, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.point1 = point1;</span><br><span class="line">        <span class="built_in">this</span>.point2 = point2;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        isAdd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.point1 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.point2 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.weight = <span class="number">0</span>;</span><br><span class="line">        isAdd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;point1 : &quot;</span> + point1 + <span class="string">&quot; point2 : &quot;</span> + point2 + <span class="string">&quot; weight = &quot;</span> + weight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="section6"></a></p><h3 id="3-实验结束时的程序清单及运行结果及实验总结"><a href="#3-实验结束时的程序清单及运行结果及实验总结" class="headerlink" title="3.实验结束时的程序清单及运行结果及实验总结"></a>3.实验结束时的程序清单及运行结果及实验总结</h3><p>点 1</p><p>点 2</p><p>点 3</p><p>点 4</p><p>点 5</p><p>第1条边 : point1 : 1 point2 : 2 weight = 1</p><p>第2条边 : point1 : 5 point2 : 2 weight = 1</p><p>第3条边 : point1 : 3 point2 : 4 weight = 2</p><p>第4条边 : point1 : 5 point2 : 1 weight = 2</p><p>第5条边 : point1 : 2 point2 : 3 weight = 2</p><p>第6条边 : point1 : 4 point2 : 2 weight = 2</p><p>第7条边 : point1 : 4 point2 : 5 weight = 3</p><p>第8条边 : point1 : 1 point2 : 4 weight = 3</p><p>有回路，跳过原第4 条边</p><p>有回路，跳过原第5 条边</p><p>已添加完4条边，不再继续添加(注意：本算法只列出了一种最小生成树！）</p><p>第1条边 : point1 : 1 point2 : 2 weight = 1</p><p>第2条边 : point1 : 5 point2 : 2 weight = 1</p><p>第3条边 : point1 : 3 point2 : 4 weight = 2</p><p>第4条边 : point1 : 4 point2 : 2 weight = 2</p><p>Process finished with exit code 0</p><p>总结的话在（1）里面已经总结了</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 离散数学 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
