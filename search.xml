<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>两道离散数学中的算法题</title>
      <link href="/2023/06/15/%E4%B8%A4%E9%81%93%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/2023/06/15/%E4%B8%A4%E9%81%93%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>记录一下在学习离散数学的时候的两个实验，用 java 实现 warshall 算法来求传递闭包，用Kruskal 算法来求最小生成树</p><span id="more"></span><hr><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p> <strong>1.Warshall 算法求传递闭包</strong><br><a href="#section1">1.实验过程中遇到的问题及其解决过程</a><br><a href="#section2">2.实现算法并编写一个程序求出给定关系的闭包</a><br><a href="#section3">3.实验结束时的程序清单及运行结果及实验总结</a></p><p><strong>2.Kruskal 算法求最小生成树</strong><br><a href="#section4">1.实验过程中遇到的问题及其解决过程</a><br><a href="#section5">2.利用Java语言编写一个程序求出给定无向连通加权图的一棵最小生成树</a><br><a href="#section6">3.实验结束时的程序清单及运行结果及实验总结</a></p><hr><h2 id="1-Warshall-算法求传递闭包"><a href="#1-Warshall-算法求传递闭包" class="headerlink" title="1.Warshall 算法求传递闭包"></a>1.Warshall 算法求传递闭包</h2><p><a name="section1"></a></p><h3 id="1-实验过程遇到的问题及其解决过程"><a href="#1-实验过程遇到的问题及其解决过程" class="headerlink" title="1.实验过程遇到的问题及其解决过程"></a>1.实验过程遇到的问题及其解决过程</h3><p>如何设计算法，利用自然的逻辑进行，先循环每一行i，在检查第 i 列有哪些元素为 1，记录这些列号 j，把第 i 行的元素利用逻辑加法（我采用了三目运算）加到第 j 行，这里引入了第三层循环 ，并且每次运算都做了打印处理方便调试<br><a name="section2"></a></p><h3 id="2-实现算法并编写一个程序求出给定关系的闭包"><a href="#2-实现算法并编写一个程序求出给定关系的闭包" class="headerlink" title="2.实现算法并编写一个程序求出给定关系的闭包"></a>2.实现算法并编写一个程序求出给定关系的闭包</h3><p><strong>Warshall类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Warshall</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化矩阵</span></span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                arr[i][j] = <span class="number">0</span>;<span class="comment">//先将所有元素设置为 0，再具体添加测试</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        printArr(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//warshall算法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//循环每一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//看第 i 列哪些元素为 1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//第 j 行 i 列的元素为 1</span></span><br><span class="line">                    <span class="comment">//把第 i 行的所有元素逻辑加到第 j 行</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>; s &lt; <span class="number">4</span>; s++) &#123;</span><br><span class="line">                        arr[j][s] = (arr[j][s] + arr[i][s]) == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>;<span class="comment">//利用三目运算符</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">//每循环一行打印一次矩阵</span></span><br><span class="line">            System.out.println(<span class="string">&quot;\n----------第&quot;</span> + count + <span class="string">&quot;次-----------\n&quot;</span>);</span><br><span class="line">            printArr(arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArr</span><span class="params">(<span class="type">int</span>[][] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] i : arr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">4</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                    count = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(j + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a name="section3"></a></p><h3 id="3-实验结束的程序清单及运行结果及实验总结"><a href="#3-实验结束的程序清单及运行结果及实验总结" class="headerlink" title="3.实验结束的程序清单及运行结果及实验总结"></a>3.实验结束的程序清单及运行结果及实验总结</h3><p>0 1 0 0</p><p>0 0 1 1</p><p>1 1 0 0</p><p>1 0 0 0<br>—————第1次—————-</p><p>0 1 0 0</p><p>0 0 1 1</p><p>1 1 0 0</p><p>1 1 0 0<br>—————第2次—————-</p><p>0 1 1 1</p><p>0 0 1 1</p><p>1 1 1 1</p><p>1 1 1 1<br>—————第3次—————-</p><p>1 1 1 1</p><p>1 1 1 1</p><p>1 1 1 1</p><p>1 1 1 1<br>—————第4次—————-</p><p>1 1 1 1</p><p>1 1 1 1</p><p>1 1 1 1</p><p>1 1 1 1<br>Process finished with exit code 0<br>实验总结：<br>编写程序之前要理解 warshall 算法的步骤，才能清晰的写出程序运行逻辑</p><hr><h2 id="2-Kruskal-算法求最小生成树"><a href="#2-Kruskal-算法求最小生成树" class="headerlink" title="2.Kruskal 算法求最小生成树"></a>2.Kruskal 算法求最小生成树</h2><p><a name="section4"></a></p><h3 id="1-实验过程中遇到的问题及其解决过程"><a href="#1-实验过程中遇到的问题及其解决过程" class="headerlink" title="1.实验过程中遇到的问题及其解决过程"></a>1.实验过程中遇到的问题及其解决过程</h3><p>难点在于怎么样把图 G<V,E,C>设计成一些类的组合   </p><p>我在实现过程中，封装了 Graph 类表示图，Edge 表示边，并且把权重封装在 Edge 类中作为属性(为了方便权限设置为 public)，并且在 Graph 类中创建静态方法，实现打印点，边，按权重为边集合排序和初始化边集合的静态方法，直接在 main 方法中用 Edge 类调用，在 Kruskal 类中，我抽取了三个静态方法，实现 main 方法的简洁性，提高了代码的阅读性。   </p><p>第一个静态方法是设置点集合，可以在静态方法中自己调试点的个数，同理第二个静态方法是设置边集合，可以调试一些带权连通图，只需要把这些关系自己创建出对应的边即可，第三个静态方法是 Kruskal 算法的实现，我在里面利用一些计数器原理判断是否已经添加了（点数 -1）条边，并且利用 Graph 类封装的 isAdd 属性配合一个判断是否有回路的算法，来生成最小生成树的图newGraph</p><p> 中间遇到了一些问题通过断点调试 debug 解决了，主要是一些下标处理问题，在没有 isAdd 属性的时候，会有一些造成回路的边被重复判断，还有是引入了 count 防止跳过造成回路的边之后，i 的值作为下标赋值给新边的时候造成 ArrayIndexOutOfBounds 异常，暂且测试了两个例子，后面有时间会进行更多测试，并且支持自定义添加图，并判断是否为连通图再进行最小生成树的生成操作</p><p><a name="section5"></a></p><h3 id="2-利用Java语言编写一个程序求出给定无向连通加权图的一棵最小生成树"><a href="#2-利用Java语言编写一个程序求出给定无向连通加权图的一棵最小生成树" class="headerlink" title="2.利用Java语言编写一个程序求出给定无向连通加权图的一棵最小生成树"></a>2.利用Java语言编写一个程序求出给定无向连通加权图的一棵最小生成树</h3><p><strong>Kruskal类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kruskal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//设置点集合</span></span><br><span class="line">        <span class="type">int</span>[] points = setPoint();</span><br><span class="line">        <span class="comment">//设置边集合</span></span><br><span class="line">        Edge[] edges = setEdge();</span><br><span class="line">        <span class="comment">//Kruskal算法</span></span><br><span class="line">        kruskalMethod(points, edges);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">kruskalMethod</span><span class="params">(<span class="type">int</span>[] points, Edge[] edges)</span> &#123;</span><br><span class="line">        <span class="comment">//Kruskal算法</span></span><br><span class="line">        <span class="comment">//按照权重从小到大的顺序添加边，已经排序好了直接按照边序号来</span></span><br><span class="line">        <span class="comment">//创建新图(只需要点的总数-1 条边）</span></span><br><span class="line">        Edge[] newEdge = <span class="keyword">new</span> <span class="title class_">Edge</span>[points.length - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化新边集合</span></span><br><span class="line">        Graph.setEmptyEdge(newEdge);</span><br><span class="line">        <span class="type">Graph</span> <span class="variable">newGraph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>(points, newEdge);</span><br><span class="line">        <span class="comment">//循环添加新边</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">            <span class="comment">//设置第一,二条边</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == <span class="number">1</span>) &#123;</span><br><span class="line">                newGraph.edges[i].point1 = edges[i].point1;</span><br><span class="line">                newGraph.edges[i].point2 = edges[i].point2;</span><br><span class="line">                newGraph.edges[i].weight = edges[i].weight;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当边数超过三时，需要判断是否形成回路，如果新生成的边的终点和前面已存在的边的起点重合，则判断为回路</span></span><br><span class="line">                <span class="keyword">if</span> (count == points.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;已添加完&quot;</span> + count + <span class="string">&quot;条边，不再继续添加(注意：本算法只列出了一种最小生成树！）&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//利用循环判断是否有回路</span></span><br><span class="line">                <span class="type">int</span> j;</span><br><span class="line">                <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                    <span class="comment">//如果跳过了一条边，也相当于添加过了，就不要再重新比了，相当于做了一个标记，这条边我不要</span></span><br><span class="line">                    <span class="keyword">if</span> (edges[i].point2 == edges[j].point1 &amp;&amp; !edges[j].isAdd) &#123;</span><br><span class="line">                        edges[i].isAdd = <span class="literal">true</span>;</span><br><span class="line">                        System.out.println(<span class="string">&quot;有回路，跳过原第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot; 条边&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断上方是否正常跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//break 跳出，说明有回路，更新 i 为下一条边</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//正常退出，正常添加新边,注意要用 count 来为新的边赋值，否则会随着一些边的跳过，导致 i 作为新边下标的越界问题</span></span><br><span class="line">                    newGraph.edges[count].point1 = edges[i].point1;</span><br><span class="line">                    newGraph.edges[count].point2 = edges[i].point2;</span><br><span class="line">                    newGraph.edges[count].weight = edges[i].weight;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看新边集合</span></span><br><span class="line">        Graph.printEdges(newGraph.edges);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] setPoint() &#123;</span><br><span class="line">        <span class="comment">//创建点集合</span></span><br><span class="line">        <span class="type">int</span>[] points = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//将点集合的值视为编号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            points[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印点集合</span></span><br><span class="line">        Graph.printPoints(points);</span><br><span class="line">        <span class="keyword">return</span> points;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Edge[] setEdge() &#123;</span><br><span class="line">        <span class="comment">//构造连通图</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1-2,5</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2-3,5</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3-5,6</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2-4,12</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 4-5,12</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2-5,15</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3-4,17</span></span><br><span class="line"><span class="comment">         //         */</span></span><br><span class="line"><span class="comment">//        Edge[] edges = new Edge[7];</span></span><br><span class="line"><span class="comment">//        edges[0] = new Edge(1, 2, 5);</span></span><br><span class="line"><span class="comment">//        edges[1] = new Edge(2, 3, 5);</span></span><br><span class="line"><span class="comment">//        edges[2] = new Edge(3, 5, 6);</span></span><br><span class="line"><span class="comment">//        edges[3] = new Edge(2, 4, 12);</span></span><br><span class="line"><span class="comment">//        edges[4] = new Edge(4, 5, 12);</span></span><br><span class="line"><span class="comment">//        edges[5] = new Edge(2, 5, 15);</span></span><br><span class="line"><span class="comment">//        edges[6] = new Edge(3, 4, 17);</span></span><br><span class="line">        Edge[] edges = <span class="keyword">new</span> <span class="title class_">Edge</span>[<span class="number">8</span>];</span><br><span class="line">        edges[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        edges[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">        edges[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">        edges[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">        edges[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        edges[<span class="number">5</span>] = <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">        edges[<span class="number">6</span>] = <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        edges[<span class="number">7</span>] = <span class="keyword">new</span> <span class="title class_">Edge</span>(<span class="number">4</span>, <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//按权重排序</span></span><br><span class="line">        Graph.sortEdge(edges);</span><br><span class="line">        <span class="comment">//打印边集合</span></span><br><span class="line">        Graph.printEdges(edges);</span><br><span class="line">        <span class="keyword">return</span> edges;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Graph类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] points;</span><br><span class="line">    <span class="keyword">public</span> Edge[] edges;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">(<span class="type">int</span>[] points, Edge[] edges)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.points = points;</span><br><span class="line">        <span class="built_in">this</span>.edges = edges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printPoints</span><span class="params">(<span class="type">int</span>[] points)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : points) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;点 &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printEdges</span><span class="params">(Edge[] edges)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (Edge e : edges) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;第&quot;</span> + count + <span class="string">&quot;条边 : &quot;</span>);</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sortEdge</span><span class="params">(Edge[] edges)</span> &#123;</span><br><span class="line">        <span class="comment">//遍历权重</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; edges.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (edges[j].weight &lt; edges[i].weight) &#123;</span><br><span class="line">                    <span class="type">Edge</span> <span class="variable">tmp</span> <span class="operator">=</span> edges[j];</span><br><span class="line">                    edges[j] = edges[i];</span><br><span class="line">                    edges[i] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setEmptyEdge</span><span class="params">(Edge[] edges)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">            edges[i] = <span class="keyword">new</span> <span class="title class_">Edge</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Edge类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> point1;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> point2;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> isAdd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> point1, <span class="type">int</span> point2, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.point1 = point1;</span><br><span class="line">        <span class="built_in">this</span>.point2 = point2;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        isAdd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.point1 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.point2 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.weight = <span class="number">0</span>;</span><br><span class="line">        isAdd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;point1 : &quot;</span> + point1 + <span class="string">&quot; point2 : &quot;</span> + point2 + <span class="string">&quot; weight = &quot;</span> + weight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="section6"></a></p><h3 id="3-实验结束时的程序清单及运行结果及实验总结"><a href="#3-实验结束时的程序清单及运行结果及实验总结" class="headerlink" title="3.实验结束时的程序清单及运行结果及实验总结"></a>3.实验结束时的程序清单及运行结果及实验总结</h3><p>点 1</p><p>点 2</p><p>点 3</p><p>点 4</p><p>点 5</p><p>第1条边 : point1 : 1 point2 : 2 weight = 1</p><p>第2条边 : point1 : 5 point2 : 2 weight = 1</p><p>第3条边 : point1 : 3 point2 : 4 weight = 2</p><p>第4条边 : point1 : 5 point2 : 1 weight = 2</p><p>第5条边 : point1 : 2 point2 : 3 weight = 2</p><p>第6条边 : point1 : 4 point2 : 2 weight = 2</p><p>第7条边 : point1 : 4 point2 : 5 weight = 3</p><p>第8条边 : point1 : 1 point2 : 4 weight = 3</p><p>有回路，跳过原第4 条边</p><p>有回路，跳过原第5 条边</p><p>已添加完4条边，不再继续添加(注意：本算法只列出了一种最小生成树！）</p><p>第1条边 : point1 : 1 point2 : 2 weight = 1</p><p>第2条边 : point1 : 5 point2 : 2 weight = 1</p><p>第3条边 : point1 : 3 point2 : 4 weight = 2</p><p>第4条边 : point1 : 4 point2 : 2 weight = 2</p><p>Process finished with exit code 0</p><p>总结的话在（1）里面已经总结了</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散数学 </tag>
            
            <tag> 算法，Warshall，Kruskal </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
